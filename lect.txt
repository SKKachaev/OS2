[18.10.14]
ДЗ:
	nasm assembler x86_32 
	В тетради пояснение (1)
	Или можно придумать свой ассемблер
	[wiki]кодогенерация 
x86_32:
move
	основной синтаксис: move to, from
		to :: reg, memory
		from :: reg, memory, constant
	memory : 	absolute
				relative to reg
					-> volatile to iptlen(instr)
						volatile :: long
						volatile :: short
				indirect
jmp
	осн син: jmp to
		to :: 	reg + (reglconst)*const
				constant ->
					short
					long 
						:: 	absol
							relative
							to iptLen(inst)
				[ indirect ]
call -//-//-//-
mov
	осн син mov: 	reg <- abs mem
					reg <- const
					reg <- [abs mem]
					reg <- reg
					abs mem <- reg
					abs mem <- const
jmp
	осн син jmp:	abs reg
					relative short const <- E8
					absolute long const
					[absolute reg]
					[absolute long const]
call
	call:	absolute reg
			[absolute reg]
			relative long constant <- C2

linking algebra:
	(2) (dynamic linking)
		relocation table = [(off, name, type)]
		symble table = [(name, off)]
	(static linking) :: [.o] -> .o
		имена ссылаются только на то, что есть у нас
		берем таблицу релокаций и заполняем все дырки (name)
	.exe это такой .o в котором пустая таблица релокаций
	
Теперь хотим всем статически слинкованные библиотеки применять в .exe
	dynamic link/load of static bins :: static -> ассемблерный код
		(3) простой .exe и сложный .exe
		Для сложного .exe: если загрузить все lib и заткнуть rel символами из них, то ОБЯЗАТЕЛЬНО rel станет пустой
	lasy -//-//-// :: dynamic
		(4) 
			первый способ: мы можем кэшировать, что потребовалось от библиотек первому процессу и тогда последующие будут copy-on-write брать у него, если есть
				проблема: мы копируем целыми страницами по 4096 и если у нас замаплено в разные куски — нам будет очень печально копировать очень много всего ненужного
				решение: 	layout & cache пройтись сразу и сделать все релокации
					давайте для каждой библиотеки писать адрес, куда он должна была бы быть загружена
					лэйаутинг — это возьмем все наши самые нужные программы и сделаем это преобразование для них и попытаемся выполнить инвариант (и это второй способ)
			третий способ: поместить все релокации в одно место (GOT/PLT) <- PIC (новая версия этого говна)
				.GOT table (5)
				Какие-то рассуждения о том, что в x86_32 мы при этом можем не изпользовать relative operation
				(5)(ABI) !!!
				call: куча ljmp
					Получаем очень хороший бранч предикшн
				какте-то проблемы с 86_64 (только наоборот) с теми же самыми relative указателями
					решение : .PLT (или это не решение...)
					решение2: (6) позволяет вычислить разницу между текущим инстрактором и .GOT
			третий + LD_PRELOAD
		1-3: для динамического загрузчика это все релокации
			четвертый: lazy (модификация GOT/PLT)
				давайте мы не будет заполнять GOT\PLT сразу
				как это сделано: (7)
					_gmon_start (в epx адрес GOT, а в верхнем регистре адрес библиотеки, куда нужно слинковать)
					на картиночке нарисован запуск
				Ленивость только для функций!
			пятый: (для x86_32) библиотеки в PIC, а программы нормально
				релокация копирования: тырим у библиотеки переменную. Ей придется обращаться к нам
			шестой: взятие адреса функции должно совпадать во всех еденицах трансляции (т.е. быть константой с lazy)

Plan9
	статическая линковка с фанкшнл левелом и дедупликацией

ELF
	readelf -a /bin/bash — расшифрует elf для /bin/bash	
	бьется все на куски и рассказывает, куда что разложить и с какими правами
	Таблица секций / Таблица сегментов
	gcc -g добавляет секцию в ELF
	Секции:
		.SYM символы как строки
		.HASH смещение в .SYM -> offset в коде
		.REL таблица релокаций
		.GOT
		.GOT.PLT
		.PLT
		Код программы
		...
		.init __init ф-я, которая инфициализирует все глобальные конструкторы(функции)
		.ctors все конструкторы
		.interp ядро запускает этот файл с ним самим в качестве интерпретатора
		...
	Статическая линковка: одинаковые секции склеиваем